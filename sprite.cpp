#include "sprite.h"

const uint8_t Sprite::MAN_SIZE       = 4;
const uint8_t Sprite::STAR_SIZE      = 4;
const uint8_t Sprite::VICTORY_SIZE   = 32;

const uint8_t Sprite::man []= {
  0x69,0x96
//  0,1,1,0,
//  1,0,0,1,
//  1,0,0,1,
//  0,1,1,0
};

const uint8_t Sprite::star [] = {
  0x96,0x69
//  1,0,0,1,
//  0,1,1,0,
//  0,1,1,0,
//  1,0,0,1
};

const uint8_t Sprite::victory [] = {
      0x00,0x0F,0xE0,0x00,
      0x00,0x30,0x1C,0x00,
      0x00,0xC0,0x03,0x00,
      0x01,0x00,0x00,0x80,
      0x02,0x00,0x00,0x40,
      0x04,0x00,0x00,0x20,
      0x08,0xE0,0x07,0x10,
      0x09,0x10,0x08,0x88,
      0x11,0x10,0x08,0x88,
      0x11,0x20,0x09,0x04,
      0x20,0xC0,0x06,0x04,
      0x20,0x00,0x00,0x04,
      0x20,0x00,0x00,0x02,
      0x40,0x7F,0xF0,0x02,
      0x41,0x84,0x4F,0x02,
      0x47,0x04,0x44,0xC2,
      0x48,0x84,0x44,0x22,
      0x48,0x84,0x44,0x24,
      0x48,0x84,0x44,0x24,
      0x28,0x84,0x44,0x24,
      0x27,0x84,0x45,0xC4,
      0x14,0xFF,0xFE,0x48,
      0x12,0x84,0x44,0x88,
      0x09,0x84,0x45,0x10,
      0x04,0xC4,0x46,0x20,
      0x02,0x3C,0x78,0x40,
      0x01,0x07,0xC0,0x80,
      0x00,0xC0,0x03,0x00,
      0x00,0x38,0x0C,0x00,
      0x00,0x07,0xF0,0x00,
      0x00,0x00,0x00,0x00,
      0x00,0x00,0x00,0x00
    
    
//        4       1       4       1       4       1       4       1
//  0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,
//  0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,
//  0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,
//  0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,
//  0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,  // 5
//  0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,
//  0,0,0,0,1,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,1,0,0,0,0,
//  0,0,0,0,1,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,
//  0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,
//  0,0,0,1,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,1,0,0,  // 10 
//  0,0,1,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,0,0,
//  0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,
//  0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,
//  0,1,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,0,
//  0,1,0,0,0,0,0,1,1,0,0,0,0,1,0,0,0,1,0,0,1,1,1,1,0,0,0,0,0,0,1,0,  // 15
//  0,1,0,0,0,1,1,1,0,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,1,1,0,0,0,0,1,0,
//  0,1,0,0,1,0,0,0,1,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,0,1,0,
//  0,1,0,0,1,0,0,0,1,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,1,0,0,
//  0,1,0,0,1,0,0,0,1,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,1,0,0,
//  0,0,1,0,1,0,0,0,1,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,1,0,0,  // 20
//  0,0,1,0,0,1,1,1,1,0,0,0,0,1,0,0,0,1,0,0,0,1,0,1,1,1,0,0,0,1,0,0,
//  0,0,0,1,0,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,
//  0,0,0,1,0,0,1,0,1,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,1,0,0,0,1,0,0,0,
//  0,0,0,0,1,0,0,1,1,0,0,0,0,1,0,0,0,1,0,0,0,1,0,1,0,0,0,1,0,0,0,0,
//  0,0,0,0,0,1,0,0,1,1,0,0,0,1,0,0,0,1,0,0,0,1,1,0,0,0,1,0,0,0,0,0,  // 25
//  0,0,0,0,0,0,1,0,0,0,1,1,1,1,0,0,0,1,1,1,1,0,0,0,0,1,0,0,0,0,0,0,
//  0,0,0,0,0,0,0,1,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,
//  0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,
//  0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,
//  0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,  // 30  
//  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
//  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0  
};
    
Sprite::Sprite(uint8_t size, const uint8_t *sprite, const spriteTypes type) : pos(0,0) {
  this->size = size;
  this->sprite = sprite;
  this->type = type;
}

Sprite::~Sprite() {
  eraseCurrent();  
}

pos_t Sprite::whereAmI() {
  return pos;
}

void Sprite::draw(pos_t pos, uint8_t color) {
  const uint8_t sizeHalf = size/2;
  uint8_t zx = pos.x-sizeHalf;
  uint8_t zy = pos.y-sizeHalf;
  uint8_t bytesPerRow = size > 8 ? (size/8) + (8 / (size%8)) + ( (8 % (size%8) != 0 )?1:0 ) : 0;
  uint8_t rowsPerByte = 8/size;
  for ( uint8_t x=0; x<size; x++ ) {
    int cx = zx+x;
    for ( uint8_t y =0; y<size; y++ ) {
      uint8_t pix;
      if ( type == PLAIN ) pix = sprite[x+(size*y)];
      else if ( type == COMPRESSED ) {
        uint8_t idx = (x/8) + (bytesPerRow ? y*bytesPerRow : y/rowsPerByte);
        uint8_t rshift = (bytesPerRow > 0 ) ? 7- x%8 : 7 - (x%8 + ((y%rowsPerByte)*size));
        pix = (sprite[idx]>>rshift)&0x01;
      }

      if ( !pix ) continue;
      uView.pixel(cx, zy+y,color, NORM);  
    }
  }    
}

void Sprite::eraseCurrent() {
  draw(pos,BLACK);  
}
 
void Sprite::draw(pos_t newPos) {
  eraseCurrent();
  draw(newPos,WHITE);
  pos = newPos;  
}

bool Sprite::isColliding(pos_t aPos) {
return ( aPos.x >= pos.x-size
       && aPos.x <= pos.x+size
       && aPos.y >= pos.y-size );  
}

bool Sprite::isColliding(Sprite *other) {
  pos_t whereIsHe = other->whereAmI();

  return isColliding(whereIsHe);  
}
