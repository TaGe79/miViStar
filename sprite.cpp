#include "sprite.h"

const uint8_t Sprite::MAN_SIZE       = 4;
const uint8_t Sprite::STAR_SIZE      = 4;
const uint8_t Sprite::VICTORY_SIZE   = 40;

const uint8_t Sprite::man []= {
  0x69,0x96
//  0,1,1,0,
//  1,0,0,1,
//  1,0,0,1,
//  0,1,1,0
};

const uint8_t Sprite::star [] = {
  0x96,0x69
//  1,0,0,1,
//  0,1,1,0,
//  0,1,1,0,
//  1,0,0,1
};

const uint8_t Sprite::vis [] = {
0x00,0x00,0x0C,0x00,0x00,0x01,0x87,0x00,0x1F,0x80,0x01,0x86,0x00,0x38,0xC0,0x01,0x8C,0x78,0x30,0x00,0x00,0xD8,0x18,0x1F,0x00,0x00,0xF8,0x30,0x01,0x80,0xE0,0xF0,0x30,0x71,0x87,0xE0,0xE1,0xFE,0x1F,0x07
};

const uint8_t Sprite::victory [] = {
      0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xFF,0x80,0x00,0x00,0x07,0xFF,
      0xE0,0x00,0x00,0x1F,0xFF,0xF0,0x00,0x00,0xFE,0x00,0xFE,0x00,0x00,
      0xF8,0x00,0x3F,0x00,0x03,0xE0,0x00,0x07,0x80,0x03,0xC0,0x00,0x07,
      0xC0,0x0F,0x00,0x00,0x00,0xE0,0x0E,0x00,0x00,0x00,0xF0,0x1C,0x00,
      0x00,0x00,0x70,0x3C,0x3F,0x01,0xF8,0x38,0x38,0x7F,0x83,0xFC,0x38,
      0x70,0xF3,0xC7,0x9E,0x1C,0x70,0xE1,0xC7,0x0E,0x1C,0x70,0x40,0x82,
      0x04,0x0E,0x70,0x00,0x00,0x00,0x0E,0x70,0x00,0x00,0x00,0x0E,0xE0,
      0x00,0x00,0x00,0x0E,0xE0,0x00,0x00,0x00,0x0E,0xE3,0xFF,0xFF,0xFF,
      0xCE,0xE3,0xFF,0xFF,0xFF,0xCE,0xE3,0x06,0x00,0xC1,0xCE,0xE3,0x06,
      0x00,0xC1,0xCE,0x73,0x06,0x00,0xC1,0xCE,0x73,0x86,0x00,0xC3,0x8E,
      0x73,0x86,0x00,0xC3,0x9E,0x71,0xC6,0x00,0xC7,0x1C,0x79,0xE6,0x00,
      0xC7,0x3C,0x3C,0xF6,0x00,0xDE,0x38,0x1C,0x7E,0x00,0xFC,0x70,0x0E,
      0x7E,0x00,0xFC,0xF0,0x0F,0x1F,0xFF,0xF0,0xE0,0x07,0x87,0xFF,0xE3,
      0xC0,0x03,0xE0,0x7C,0x07,0x80,0x01,0xF0,0x00,0x1F,0x00,0x00,0xFE,
      0x00,0xFE,0x00,0x00,0x3F,0xFF,0xF8,0x00,0x00,0x1F,0xFF,0xF0,0x00,
      0x00,0x01,0xFF,0x00,0x00
};
    
Sprite::Sprite(uint8_t size, const uint8_t *sprite, const spriteTypes type) : pos(0,0) {
  this->width = size;
  this->height = size;
  this->sprite = sprite;
  this->type = type;
}

Sprite::Sprite(uint8_t width,uint8_t height, const uint8_t *sprite, const spriteTypes type) : pos(0,0) {
  this->width = width;
  this->height = height;
  this->sprite = sprite;
  this->type = type;  
}

Sprite::~Sprite() {
  eraseCurrent();  
}

pos_t Sprite::whereAmI() {
  return pos;
}

void Sprite::draw(pos_t pos, uint8_t color) {
  const uint8_t sizeHalfX = width/2;
  const uint8_t sizeHalfY = height/2;
  uint8_t zx = pos.x-sizeHalfX;
  uint8_t zy = pos.y-sizeHalfY;
  uint8_t bytesPerRow = width > 8 ? width / 8 + ((width % 8 == 0) ? 0 : 1) : 0;
  uint8_t rowsPerByte = 8/width;
  for ( uint8_t y =0; y<height; y++ ) {
    int cy = zy+y;    
    for ( uint8_t x=0; x<width; x++ ) {
      int cx = zx+x;
      uint8_t pix;
      if ( type == PLAIN ) pix = sprite[x+(width*y)];
      else if ( type == COMPRESSED ) {
        uint8_t idx = (x/8) + (bytesPerRow ? y*bytesPerRow : y/rowsPerByte);
        uint8_t rshift = (bytesPerRow > 0 ) ? 7- x%8 : 7 - (x%8 + ((y%rowsPerByte)*width));
        pix = (sprite[idx]>>rshift)&0x01;
      }

      if ( !pix ) continue;
      uView.pixel(cx, cy,color, NORM);  
    }
  }    
}

void Sprite::eraseCurrent() {
  draw(pos,BLACK);  
}
 
void Sprite::draw(pos_t newPos) {
  eraseCurrent();
  draw(newPos,WHITE);
  pos = newPos;  
}

bool Sprite::isColliding(pos_t aPos) {
return ( aPos.x >= pos.x-width
       && aPos.x <= pos.x+width
       && aPos.y >= pos.y-height );  
}

bool Sprite::isColliding(Sprite *other) {
  pos_t whereIsHe = other->whereAmI();

  return isColliding(whereIsHe);  
}
