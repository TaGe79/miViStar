#include "sprite.h"

const uint8_t Sprite::MAN_SIZE       = 4;
const uint8_t Sprite::STAR_SIZE      = 4;
const uint8_t Sprite::VICTORY_SIZE   = 40;

const uint8_t Sprite::man []= {
  0x69,0x96
//  0,1,1,0,
//  1,0,0,1,
//  1,0,0,1,
//  0,1,1,0
};

const uint8_t Sprite::star [] = {
  0x96,0x69
//  1,0,0,1,
//  0,1,1,0,
//  0,1,1,0,
//  1,0,0,1
};

const uint8_t Sprite::vis [] = {
0x00,0x00,0x0C,0x00,0x00,0x01,0x87,0x00,0x1F,0x80,0x01,0x86,0x00,0x38,0xC0,0x01,0x8C,0x78,0x30,0x00,0x00,0xD8,0x18,0x1F,0x00,0x00,0xF8,0x30,0x01,0x80,0xE0,0xF0,0x30,0x71,0x87,0xE0,0xE1,0xFE,0x1F,0x07
};

const uint8_t Sprite::death [] = {
      0x00,0x00,0x0F,0xFC,0x00,0x00,0x00,0x00,0x00,0xF8,0x07,0xC0,0x00,0x00,0x00,0x03,0x80,0x00,0x70,0x00,0x00,0x00,0x06,0x00,0x00,0x18,0x00,0x00,0x00,0x08,0x00,0x00,0x0C,0x00,0x00,0x00,0x10,0x00,0x00,0x06,0x00,0x00,0x00,0x30,0x00,0x00,0x03,0x00,0x00,0x00,0x20,0x00,0x00,0x01,0x00,0x00,0x00,0x40,0x00,0x00,0x01,0x80,0x00,0x00,0x40,0x00,0x00,0x00,0x80,0x00,0x00,0x40,0x00,0x00,0x00,0x80,0x00,0x00,0xD8,0x00,0x00,0x06,0xC0,0x00,0x00,0xD8,0x00,0x00,0x06,0x80,0x00,0x00,0xD8,0x00,0x00,0x04,0x80,0x00,0x00,0x48,0x00,0x00,0x04,0x80,0x00,0x00,0x48,0x00,0x00,0x04,0x80,0x00,0x00,0x6C,0x00,0x00,0x05,0x80,0x00,0x00,0x2C,0xFC,0x0F,0xCD,0x00,0x00,0x00,0x29,0xFE,0x1F,0xE7,0x00,0x00,0x00,0x1B,0xFE,0x1F,0xE6,0x00,0x00,0x00,0x19,0xFC,0x0F,0xE4,0x00,0x00,0x18,0x09,0xFC,0x0F,0xE4,0x06,0x00,0x1C,0x09,0xF8,0x07,0xC4,0x1A,0x00,0x32,0x08,0xF0,0xC3,0xC4,0x13,0x00,0x23,0x08,0x01,0xE0,0x04,0x33,0x00,0x21,0x88,0x03,0xE0,0x04,0x63,0x00,0x40,0xEC,0x03,0xF0,0x0D,0xC1,0x80,0xC0,0x3F,0x03,0xF0,0x3F,0x00,0xC0,0xC0,0x0F,0xC3,0xF0,0xFC,0x00,0xC0,0x7F,0x03,0xE3,0x31,0xB0,0x3F,0x80,0x01,0xC1,0x30,0x03,0xA0,0xE0,0x00,0x00,0x71,0xD0,0x02,0xE3,0x00,0x00,0x00,0x1C,0xDC,0x1E,0x5C,0x00,0x00,0x00,0x07,0x99,0x32,0x70,0x00,0x00,0x00,0x01,0xBB,0xF7,0x60,0x00,0x00,0x00,0x07,0x99,0x32,0x78,0x00,0x00,0x00,0x1C,0x8F,0x38,0x4E,0x00,0x00,0x0E,0x70,0x80,0x00,0xC3,0xF8,0x00,0x1F,0x80,0xC0,0x00,0xC0,0x7E,0x00,0x10,0x03,0x60,0x01,0x30,0x02,0x00,0x08,0x0C,0x38,0x06,0x1C,0x04,0x00,0x04,0x38,0x0F,0xFC,0x07,0x08,0x00,0x06,0x60,0x00,0x00,0x01,0x98,0x00,0x02,0x40,0x00,0x00,0x00,0x98,0x00,0x02,0xC0,0x00,0x00,0x00,0xD0,0x00,0x03,0x00,0x00,0x00,0x00,0x30,0x00 
};

const uint8_t Sprite::victory [] = {
      0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xFF,0x80,0x00,0x00,0x07,0xFF,
      0xE0,0x00,0x00,0x1F,0xFF,0xF0,0x00,0x00,0xFE,0x00,0xFE,0x00,0x00,
      0xF8,0x00,0x3F,0x00,0x03,0xE0,0x00,0x07,0x80,0x03,0xC0,0x00,0x07,
      0xC0,0x0F,0x00,0x00,0x00,0xE0,0x0E,0x00,0x00,0x00,0xF0,0x1C,0x00,
      0x00,0x00,0x70,0x3C,0x3F,0x01,0xF8,0x38,0x38,0x7F,0x83,0xFC,0x38,
      0x70,0xF3,0xC7,0x9E,0x1C,0x70,0xE1,0xC7,0x0E,0x1C,0x70,0x40,0x82,
      0x04,0x0E,0x70,0x00,0x00,0x00,0x0E,0x70,0x00,0x00,0x00,0x0E,0xE0,
      0x00,0x00,0x00,0x0E,0xE0,0x00,0x00,0x00,0x0E,0xE3,0xFF,0xFF,0xFF,
      0xCE,0xE3,0xFF,0xFF,0xFF,0xCE,0xE3,0x06,0x00,0xC1,0xCE,0xE3,0x06,
      0x00,0xC1,0xCE,0x73,0x06,0x00,0xC1,0xCE,0x73,0x86,0x00,0xC3,0x8E,
      0x73,0x86,0x00,0xC3,0x9E,0x71,0xC6,0x00,0xC7,0x1C,0x79,0xE6,0x00,
      0xC7,0x3C,0x3C,0xF6,0x00,0xDE,0x38,0x1C,0x7E,0x00,0xFC,0x70,0x0E,
      0x7E,0x00,0xFC,0xF0,0x0F,0x1F,0xFF,0xF0,0xE0,0x07,0x87,0xFF,0xE3,
      0xC0,0x03,0xE0,0x7C,0x07,0x80,0x01,0xF0,0x00,0x1F,0x00,0x00,0xFE,
      0x00,0xFE,0x00,0x00,0x3F,0xFF,0xF8,0x00,0x00,0x1F,0xFF,0xF0,0x00,
      0x00,0x01,0xFF,0x00,0x00
};
    
Sprite::Sprite(uint8_t size, const uint8_t *sprite, const spriteTypes type) : pos(0,0) {
  this->width = size;
  this->height = size;
  this->sprite = sprite;
  this->type = type;
}

Sprite::Sprite(uint8_t width,uint8_t height, const uint8_t *sprite, const spriteTypes type) : pos(0,0) {
  this->width = width;
  this->height = height;
  this->sprite = sprite;
  this->type = type;  
}

Sprite::~Sprite() {
  eraseCurrent();  
}

pos_t Sprite::whereAmI() {
  return pos;
}

void Sprite::draw(pos_t pos, uint8_t color) {
  const uint8_t sizeHalfX = floor(width*1.0/2.0 +0.5)+1;
  const uint8_t sizeHalfY = floor(height*1.0/2.0+0.5)+1;
  const uint8_t zx = max(pos.x-sizeHalfX,0);
  const uint8_t zy = max(pos.y-sizeHalfY,0);
  uint8_t bytesPerRow = width > 8 ? width / 8 + ((width % 8 == 0) ? 0 : 1) : 0;
  uint8_t rowsPerByte = 8/width;
  for ( uint8_t y =0; y<height; y++ ) {
    int cy = zy+y; 
    int wy = width*y;   
    for ( uint8_t x=0; x<width; x++ ) {
      int cx = zx+x;
      uint8_t pix;
      if ( type == PLAIN ) pix = sprite[x+wy];
      else if ( type == COMPRESSED ) {
        uint8_t idx = (x/8) + (bytesPerRow ? y*bytesPerRow : y/rowsPerByte);
        uint8_t rshift = (bytesPerRow > 0 ) ? 7- x%8 : 7 - (x%8 + (y%rowsPerByte)*width);
        pix = (sprite[idx] >> rshift) & 0x01;
      }

      if ( !pix ) continue;

      uView.pixel(max(min(cx,62),0), max(min(cy,47),0), color, NORM);
      
    }
  }    
}

void Sprite::eraseCurrent() {
  draw(pos,BLACK);  
}

void Sprite::hide() {
  eraseCurrent();  
}
 
void Sprite::draw(pos_t newPos) {
  if ( pos.x != 0 && pos.y != 0 ) eraseCurrent();
  draw(newPos,WHITE);
  pos = newPos;  
}

bool Sprite::isColliding(pos_t aPos) {
return ( aPos.x >= pos.x-width
       && aPos.x <= pos.x+width
       && aPos.y >= pos.y-height );  
}

bool Sprite::isColliding(Sprite *other) {
  pos_t whereIsHe = other->whereAmI();

  return isColliding(whereIsHe);  
}
